Team 4 AI Log: 

Kaylee Hou's AI Log: 

1. Prompt (Clarity)
"Create a user profile page that shows: Profile picture, Description, Statistics 
(Total Sightings, Unique Species, Favorite Species)"

"Update the entire website's color scheme and font to match the profile.html page"

2. Issues (Specificity)
Profile page showed placeholder data because the backend UserProfileController 
only returned a placeholder string. Needed to implement the full endpoint that 
calculates statistics from sightings.

Map markers weren't appearing because the location-to-coordinate mapping system was 
missing. Sightings only had text locations like "Trousdale Parkway" but no way to 
convert them to x/y coordinates on the map image.

Search functionality wasn't working because the frontend was trying to call 
/api/search but the backend SearchController expected a query parameter, and 
the frontend wasn't handling the response format correctly.
Admin panel showed "0" for all statistics because the JavaScript was trying to 
fetch from /api/users endpoint that didn't exist yet - needed to add findAll() 
 to UserService and corresponding GET endpoint.

3. Fix (Correctness)
Implemented UserProfileController with full logic:
@GetMapping("/{userId}")
public ResponseEntity<?> getProfile(@PathVariable Long userId) {
    // Get user sightings, calculate statistics (total, unique species, favorite)
    // Build species list with counts, recent sightings, and photo gallery
    // Return complete profile data as JSON
}
Created location coordinate mapping system in map.js:
const LOCATION_COORDINATES = {
  'trousdale parkway': { x: 45, y: 50 },
  'alumni park': { x: 50, y: 45 },
  // ... more mappings
};
// Then place markers using percentage-based positioning on the map image
Fixed search to handle both API search and client-side fallback:
async function performSearch(query) {
    const response = await fetch(`${API_BASE}/search?query=${encodeURIComponent(query)}`);
    // Fallback to client-side filtering if API fails
}
Added UserService.findAll() and UserController GET endpoint:
public List<User> findAll() {
    return userRepository.findAll();
}
@GetMapping
public ResponseEntity<?> getAllUsers() {
    return ResponseEntity.ok(userService.findAll());
}
4. Explanation (Depth)
These fixes ensure the application frontend works accordingly to our design doc. 
The profile controller demonstrates proper service layer separation and data 
aggregation. The coordinate mapping enables visual representation of sightings 
on a static map image. The search fallback improves robustness by handling API 
failures gracefully. Adding the users endpoint completes the admin dashboard 
functionality, showing proper REST API design and repository pattern usage. 


Prompts

	-Asked for help generating the initial HTML/CSS templates for the projectâ€™s static pages (landing, about, help, and settings). The AI produced the basic layout, including the navigation bar and page structure, but I manually adjusted the spacing, alignment, colors, and overall styling.

	-Asked the AI to help design the Settings page layout, including suggestions for input field styling, dropdown structure, section headings, and how to structure a Saved Information panel. We later rewrote portions of the layout myself, added padding, improved the spacing, and unified the UI with the rest of the pages.

Issues

	-Inconsistent spacing and alignment between pages. The AI templates had different default margins and paddings, and various pages (help vs. landing vs. settings) did not visually match.

	-CSS not applying or partially applying, caused by incorrect file paths, caching, and conflicting styles. We had to manually debug the loading order and override rules.

Fix

	-We adjusted the HTML/CSS templates generated by the AI and manually unified spacing, line-height, padding, and alignment across all static pages.

	-We rewrote large portions of the Settings page layout, including centering the entire card, adding consistent padding, and placing the Save button inside a separate action-row to control spacing.

Explanation

	-These fixes were necessary to make the static pages visually consistent and functional. The AI-generated templates provided a starting point, but the final UI (spacing, colors, typography, alignment, and page layout) required significant manual adjustments to meet the expected look and to ensure uniformity across all pages.




2. Creating the navbar
	Prompts: I want to create a navbar. Create a left side navbar with a website name, buttons below, and a signout button at the bottom.
	Issues: Color was wrong, icons used were simply apple emojis that don't match, and I lots of redundant code.
	Fix: I manually changed colors, used google icons to replace emojis, and asked AI to make a navbar file and how to
		use that else where.
	Explanation: Color and icons is important to make the website like modern and sleek. Most importantly however,
		previously I would copy paste a long html for each page as navbar. But by creating a navbar file and using
		a script to import navbar in each page, we can make code a lot cleaner and more organized. Also, modifying navbar
		doesn't require modifing every file.

3. Improving the navbar
	Prompts: I wanted navbar to highlight what page the user is currently on. I asked AI to darken buttons based off
		of the page the user is currently on.
	Issues: No buttons were highlighted no matter what I clicked.
	Fix: I found out that AI was checking for the wrong url names, and I simply had to change them to the correct file names
	Expalantion: This is a super important UI component as users need to be able to see what page they are super easily.
		Furthermore, by not checking the correct file name, we are unable to ever make the code work unless we fix it.

Sriya Pratipati's AI Log: 
 1. User Profile Backend - File Upload Configuration
Prompt (Clarity)
"Implement user profile with display name, bio, and profile picture upload functionality."
Issues (Specificity)
File upload returned 500 error because multipart configuration was missing from application.properties.
Uploaded files weren't accessible via HTTP because Spring wasn't serving static resources from the uploads directory.
Fix (Correctness)
Added to application.properties:
propertiesspring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=5MB
Created WebConfig:
java@Configuration
public class WebConfig implements WebMvcConfigurer {
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/uploads/**").addResourceLocations("file:uploads/");
    }
}
Explanation (Depth)
Multipart configuration enables file processing and prevents DOS attacks through size limits. WebConfig maps HTTP URLs to file system so browsers can fetch uploaded images.

2. User Statistics - Incorrect Query
Prompt (Clarity)
"Track user statistics (total sightings, unique species) and auto-update when sightings change. Use for leaderboard ranking."
Issues (Specificity)
All users showed 0 sightings because statistics calculation loaded all sightings into memory using streams instead of database queries.
Fix (Correctness)
Added efficient queries to SightingRepository:
javaLong countByUserId(Long userId);

@Query("SELECT COUNT(DISTINCT s.species) FROM Sighting s WHERE s.user.id = :userId")
Long countUniqueSpeciesByUserId(@Param("userId") Long userId);
Updated SightingService:
javaprivate void updateUserStatistics(Long userId) {
    user.setTotalAnimalsLogged(sightingRepository.countByUserId(userId).intValue());
    user.setUniqueSpeciesCount(sightingRepository.countUniqueSpeciesByUserId(userId).intValue());
}
Explanation (Depth)
Database-level queries prevent memory issues and N+1 problems. SQL's COUNT(DISTINCT) is optimized for this operation rather than loading thousands of records into Java collections.

3. Password Security - Plain Text Storage
Prompt (Clarity)
"Create authentication with registration and login endpoints. Validate credentials and reject duplicates."
Issues (Specificity)
Passwords stored in plain text - anyone with database access could read them.
API responses included password field in JSON responses.
Fix (Correctness)
Added BCrypt hashing:
javapublic User registerUser(String username, String password) {
    String hashed = passwordEncoder.encode(password);
    return userRepository.save(new User(username, hashed));
}

public Optional<User> login(String username, String password) {
    if (user.isPresent() && passwordEncoder.matches(password, user.get().getPassword())) {
        return user;
    }
}
Created UserDTO without password field and updated controllers:
javareturn ResponseEntity.ok(new UserDTO(created));
Explanation (Depth)
BCrypt provides one-way hashing with automatic salting to prevent rainbow table attacks. DTO pattern ensures passwords never appear in API responses, following security best practices for authentication systems.